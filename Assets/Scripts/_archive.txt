    public class MoveScore {
        public Tile move;
        public int score = 0;
        public MoveScore(Tile move, int score) {
            this.move = move;
            this.score = score;
        }
    }


    // public Tile GetBestMove(Tile[][] board, Player player) {
    //     stopwatch = Stopwatch.StartNew();
    //     AdjacentTiles adj = new AdjacentTiles(gameAdjTiles);

    //     MoveScore bestMs = MinimaxAB(board, board[0][0], player, 0, int.MinValue, int.MaxValue, adj);

    //     stopwatch.Stop();
    //     Game.Instance.UpdateLog(stopwatch.ElapsedMilliseconds, gameAdjTiles.adjTiles.Count, maxEvalAdj, evalCount, bestMs.score);
    //     UnityEngine.Debug.Log(string.Format("{0} max, {1} min, {2} alpha, {3} beta", maxCount, minCount, alphaBreak, betaBreak));
    //     evalCount = 0;
    //     maxCount = minCount = alphaBreak = betaBreak = 0;
    //     return bestMs.move;
    // }
    
    // MoveScore MinimaxAB(Tile[][] board, Tile move, Player player, int depth, int alpha, int beta, AdjacentTiles adj) {
    //     // if(move) {
    //         int score = StaticEvaluation(board, move);

    //         if(Math.Abs(score) >= 100000) {
    //             return new MoveScore(move, score);
    //         }
    //         if(depth >= Game.Instance.maxComputeDepth) {
    //             return new MoveScore(move, score);
    //         }
    //         if(stopwatch.ElapsedMilliseconds > Game.Instance.timeoutMs) {
    //             return new MoveScore(move, score);
    //         }
    //     // }
    //     if(adj.adjTiles.Count > maxEvalAdj)
    //         maxEvalAdj = adj.adjTiles.Count;

    //     if(player.id == Game.Player1.id) {
    //         MoveScore bestMove = new MoveScore(null, int.MinValue);
    //         maxCount++;

    //         for(int i = 0; i < adj.adjTiles.Count; ++i) {
    //             if(adj.adjTiles[i].occupied)
    //                 continue;

    //             adj.adjTiles[i].playerId = player.id;

    //             MoveScore temp = MinimaxAB(board, adj.adjTiles[i], player.opponent, depth+1, alpha, beta, adj);
    //             if(temp.score > bestMove.score) {
    //                 bestMove.move = temp.move;
    //                 bestMove.score = temp.score;
    //             }

    //             adj.adjTiles[i].playerId = 0;

    //             alpha = Math.Max(alpha, bestMove.score);
    //             if(alpha >= beta) {
    //                 alpha++;
    //                 return bestMove;
    //             }
    //         }
    //         return bestMove;
    //     }
    //     else { // minimize
    //         MoveScore bestMove = new MoveScore(null, int.MaxValue);
    //         minCount++;

    //         for(int i = 0; i < adj.adjTiles.Count; ++i) {
    //             if(adj.adjTiles[i].occupied)
    //                 continue;

    //             adj.adjTiles[i].playerId = player.id;

    //             MoveScore temp = MinimaxAB(board, adj.adjTiles[i], player.opponent, depth+1, alpha, beta, adj);
    //             if(temp.score < bestMove.score) {
    //                 bestMove.move = adj.adjTiles[i];
    //                 bestMove.score = temp.score;
    //             }

    //             adj.adjTiles[i].playerId = 0;

    //             beta = Math.Min(beta, bestMove.score);
    //             if(beta <= alpha) {
    //                 beta++;
    //                 return bestMove;
    //             }
    //         }
    //         return bestMove;
    //     }
    // }







    // int EvaluateHorizontal(Tile[][] board, Tile move) {
    //     int leftCount = 0;

    //     for(int c = move.x - 1; c >= 0; --c) 
    //     {
    //         if(board[move.y][c].occupied && board[move.y][c].playerId != move.playerId) {
    //             break;
    //         }
    //         evalTiles.Enqueue(board[move.y][c]);
    //     }
    //     leftCount = evalTiles.Count;

    //     for(int c = move.x + 1; c < board.Length; ++c) 
    //     {
    //         if(board[move.y][c].occupied && board[move.y][c].playerId != move.playerId) {
    //             break;
    //         }
    //         evalTiles.Enqueue(board[move.y][c]);
    //     }
    //     return EvaluateTiles(evalTiles, leftCount, move);
    // }
    // int EvaluateVertical(Tile[][] board, Tile move) {
    //     int leftCount = 0;

    //     for(int r = move.y - 1; r >= 0; --r)
    //     {
    //         if(board[r][move.x].occupied && board[r][move.x].playerId != move.playerId)
    //             break;
    //         evalTiles.Enqueue(board[r][move.x]);
    //     }
    //     leftCount = evalTiles.Count;

    //     for(int r = move.y + 1; r < board.Length; ++r)
    //     {
    //         if(board[r][move.x].occupied && board[r][move.x].playerId != move.playerId)
    //             break;
    //         evalTiles.Enqueue(board[r][move.x]);
    //     }
    //     return EvaluateTiles(evalTiles, leftCount, move);
    // }
    // int EvaluateDiagonalFall(Tile[][] board, Tile move) {
    //     int leftCount = 0;

    //     for(int i = 1; (move.y - i) >= 0 && (move.x - i) >= 0; ++i) 
    //     {
    //         if(board[move.y - i][move.x - i].occupied && board[move.y - i][move.x - i].playerId != move.playerId)
    //             break;
    //         evalTiles.Enqueue(board[move.y - i][move.x - i]);
    //     }
    //     leftCount = evalTiles.Count;

    //     for(int i = 1; (move.y + i) < board.Length && (move.x + i) < board.Length; ++i)
    //     {
    //         if(board[move.y + i][move.x + i].occupied && board[move.y + i][move.x + i].playerId != move.playerId)
    //             break;
    //         evalTiles.Enqueue(board[move.y + i][move.x + i]);
    //     }

    //     return EvaluateTiles(evalTiles, leftCount, move);
    // }
    // int EvaluateDiagonalRise(Tile[][] board, Tile move) {
    //     int leftCount = 0;

    //     for(int i = 1; (move.y - i) >= 0  && (move.x + i) < board.Length; ++i) 
    //     {
    //         if(board[move.y - i][move.x + i].occupied && board[move.y - i][move.x + i].playerId != move.playerId)
    //             break;
    //         evalTiles.Enqueue(board[move.y - i][move.x + i]);
    //     }
    //     leftCount = evalTiles.Count;

    //     for(int i = 1; (move.y + i) < board.Length && (move.x - i) >= 0; ++i)
    //     {

    //         if(board[move.y + i][move.x - i].occupied && board[move.y + i][move.x - i].playerId != move.playerId)
    //             break;
    //         evalTiles.Enqueue(board[move.y + i][move.x - i]);
    //     }

    //     return EvaluateTiles(evalTiles, leftCount, move);
    // }